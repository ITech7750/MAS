{"version":3,"file":"react-jobs.min.js","sources":["../src/utils.js","../src/withJob.js","../src/createJobContext.js","../src/JobProvider.js"],"sourcesContent":["export function getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component'\n}\n\nexport const isPromise = x =>\n  typeof x === 'object' && typeof x.then === 'function'\n\nexport const propsWithoutInternal = props => {\n  // eslint-disable-next-line no-unused-vars\n  const { jobInitState, onJobProcessed, ...rest } = props\n  return rest\n}\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { getDisplayName, isPromise, propsWithoutInternal } from './utils'\n\nconst validSSRModes = ['resolve', 'defer', 'boundary']\nconst neverWorkAgain = () => false\n\nexport default function withJob(config) {\n  if (typeof config !== 'object') {\n    throw new Error('You must provide a config object to withJob')\n  }\n\n  const {\n    work,\n    LoadingComponent,\n    ErrorComponent,\n    serverMode = 'resolve',\n    shouldWorkAgain = neverWorkAgain,\n  } = config\n\n  if (typeof work !== 'function') {\n    throw new Error('You must provide a work function to withJob')\n  }\n\n  if (validSSRModes.indexOf(serverMode) === -1) {\n    throw new Error('Invalid serverMode provided to asyncComponent')\n  }\n\n  const env = typeof window === 'undefined' ? 'node' : 'browser'\n\n  return function wrapWithJob(WrappedComponent) {\n    let id\n\n    class ComponentWithJob extends Component {\n      static displayName = `WithJob(${getDisplayName(WrappedComponent)})`\n\n      static contextTypes = {\n        jobs: PropTypes.shape({\n          getNextId: PropTypes.func.isRequired,\n          register: PropTypes.func.isRequired,\n          get: PropTypes.func.isRequired,\n          getRehydrate: PropTypes.func.isRequired,\n          removeRehydrate: PropTypes.func.isRequired,\n        }),\n      }\n\n      constructor(props, context) {\n        super(props, context)\n\n        // Each instance needs it's own id as that is how we expect work to\n        // be executed.  It is not shared between element instances.\n        if (context.jobs) {\n          id = context.jobs.getNextId()\n        }\n      }\n\n      // @see react-async-bootstrapper\n      bootstrap() {\n        if (env === 'browser') {\n          // No logic for browser, just continue\n          return true\n        }\n\n        // node\n        return serverMode === 'defer' ? false : this.resolveWork(this.props)\n      }\n\n      componentWillMount() {\n        let result\n\n        if (this.context.jobs) {\n          result =\n            env === 'browser'\n              ? this.context.jobs.getRehydrate(id)\n              : this.context.jobs.get(id)\n        }\n\n        this.setState({\n          data: result ? result.data : null,\n          error: null,\n          completed: result != null,\n        })\n      }\n\n      componentDidMount() {\n        if (!this.state.completed) {\n          this.resolveWork(this.props)\n        }\n\n        if (this.context.jobs && env === 'browser') {\n          this.context.jobs.removeRehydrate(id)\n        }\n      }\n\n      componentWillUnmount() {\n        this.unmounted = true\n      }\n\n      componentWillReceiveProps(nextProps) {\n        if (\n          shouldWorkAgain(\n            propsWithoutInternal(this.props),\n            propsWithoutInternal(nextProps),\n            this.getJobState(),\n          )\n        ) {\n          this.resolveWork(nextProps)\n        }\n      }\n\n      resolveWork = props => {\n        let workDefinition\n\n        this.setState({ completed: false, data: null, error: null })\n\n        try {\n          workDefinition = work(props)\n        } catch (error) {\n          this.setState({ completed: true, error })\n          // Ensures bootstrap stops\n          return false\n        }\n\n        if (isPromise(workDefinition)) {\n          // Asynchronous result.\n          return workDefinition\n            .then(data => {\n              if (this.unmounted) {\n                return undefined\n              }\n              this.setState({ completed: true, data })\n              if (this.context.jobs) {\n                this.context.jobs.register(id, { data })\n              }\n              // Ensures bootstrap continues\n              return true\n            })\n            .catch(error => {\n              if (this.unmounted) {\n                return undefined\n              }\n              if (env === 'browser') {\n                setTimeout(() => {\n                  if (!this.unmounted) {\n                    this.setState({ completed: true, error })\n                  }\n                }, 16)\n              } else {\n                // node\n                // We will at least log the error so that user isn't completely\n                // unaware of an error occurring.\n                // eslint-disable-next-line no-console\n                console.warn('Failed to resolve job')\n                // eslint-disable-next-line no-console\n                console.warn(error)\n              }\n              // Ensures bootstrap stops\n              return false\n            })\n        }\n\n        // Synchronous result.\n        this.setState({ completed: true, data: workDefinition, error: null })\n\n        // Ensures bootstrap continues\n        return true\n      }\n\n      getJobState = () => ({\n        completed: this.state.completed,\n        error: this.state.error,\n        data: this.state.data,\n      })\n\n      render() {\n        const { data, error, completed } = this.state\n\n        if (error) {\n          return ErrorComponent ? (\n            <ErrorComponent {...this.props} error={error} />\n          ) : null\n        }\n        if (!completed) {\n          return LoadingComponent ? <LoadingComponent {...this.props} /> : null\n        }\n        return <WrappedComponent {...this.props} jobResult={data} />\n      }\n    }\n\n    return ComponentWithJob\n  }\n}\n","export default function createJobContext() {\n  let idPointer = 0\n  const jobs = {}\n  return {\n    getNextId: () => {\n      idPointer += 1\n      return idPointer\n    },\n    resetIds: () => {\n      idPointer = 0\n    },\n    register: (jobID, result) => {\n      jobs[jobID] = result\n    },\n    get: jobID => jobs[jobID],\n    getState: () => ({ jobs }),\n  }\n}\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nimport createJobContext from './createJobContext'\n\nclass JobProvider extends Component {\n  static propTypes = {\n    children: PropTypes.node.isRequired,\n    jobContext: PropTypes.shape({\n      getNextId: PropTypes.func.isRequired,\n      resetIds: PropTypes.func.isRequired,\n      register: PropTypes.func.isRequired,\n      get: PropTypes.func.isRequired,\n      getState: PropTypes.func.isRequired,\n    }),\n    rehydrateState: PropTypes.shape({\n      jobs: PropTypes.object.isRequired,\n    }),\n  }\n\n  static defaultProps = {\n    jobContext: null,\n    rehydrateState: {\n      jobs: {},\n    },\n  }\n\n  static childContextTypes = {\n    jobs: PropTypes.shape({\n      getNextId: PropTypes.func.isRequired,\n      register: PropTypes.func.isRequired,\n      get: PropTypes.func.isRequired,\n      getRehydrate: PropTypes.func.isRequired,\n      removeRehydrate: PropTypes.func.isRequired,\n    }).isRequired,\n  }\n\n  constructor(props, context) {\n    super(props, context)\n\n    // This is a workaround because each element instance of a job needs its\n    // own ids.  So between the bootstrapping and the render we need to reset\n    // the id counter to ensure the ids will match.\n    if (props.jobContext) {\n      props.jobContext.resetIds()\n    }\n  }\n\n  componentWillMount() {\n    this.jobContext = this.props.jobContext || createJobContext()\n    this.rehydrateState = this.props.rehydrateState\n  }\n\n  getChildContext() {\n    return {\n      jobs: {\n        getNextId: this.jobContext.getNextId,\n        register: this.jobContext.register,\n        get: this.jobContext.get,\n        getRehydrate: id => this.rehydrateState.jobs[id],\n        removeRehydrate: id => {\n          delete this.rehydrateState.jobs[id]\n        },\n      },\n    }\n  }\n\n  render() {\n    return React.Children.only(this.props.children)\n  }\n}\n\nexport default JobProvider\n"],"names":["getDisplayName","WrappedComponent","displayName","name","isPromise","x","then","propsWithoutInternal","props","jobInitState","onJobProcessed","validSSRModes","neverWorkAgain","withJob","config","Error","work","LoadingComponent","ErrorComponent","serverMode","shouldWorkAgain","indexOf","env","window","id","ComponentWithJob","context","jobs","getNextId","this","resolveWork","result","getRehydrate","get","setState","data","state","completed","removeRehydrate","unmounted","nextProps","getJobState","error","React","jobResult","Component","contextTypes","PropTypes","shape","func","isRequired","workDefinition","_this2","register","catch","warn","createJobContext","idPointer","jobID","JobProvider","jobContext","resetIds","rehydrateState","Children","only","children","propTypes","node","object","defaultProps","childContextTypes"],"mappings":"ioDAAO,SAASA,eAAeC,UACtBA,EAAiBC,aAAeD,EAAiBE,MAAQ,YAG3D,IAAMC,UAAY,kBACV,qBAANC,sBAAAA,KAAoC,mBAAXA,EAAEC,MAEvBC,qBAAuB,YAEgBC,EAA1CC,aAA0CD,EAA5BE,8CAA4BF,sCCL9CG,cAAgB,CAAC,UAAW,QAAS,YACrCC,eAAiB,kBAAM,GAEd,SAASC,QAAQC,MACR,qBAAXA,sBAAAA,UACH,IAAIC,MAAM,mDAIhBC,EAKEF,EALFE,KACAC,EAIEH,EAJFG,iBACAC,EAGEJ,EAHFI,iBAGEJ,EAFFK,WAAAA,aAAa,cAEXL,EADFM,gBAAAA,aAAkBR,oBAGA,mBAATI,QACH,IAAID,MAAM,mDAGyB,IAAvCJ,cAAcU,QAAQF,SAClB,IAAIJ,MAAM,qDAGZO,EAAwB,oBAAXC,OAAyB,OAAS,iBAE9C,SAAqBtB,OACtBuB,SAEEC,yBAaQjB,EAAOkB,iHACXlB,EAAOkB,qBAITA,EAAQC,SACLD,EAAQC,KAAKC,2FAMR,YAARN,GAMkB,UAAfH,GAAiCU,KAAKC,YAAYD,KAAKrB,wDAI1DuB,SAEAF,KAAKH,QAAQC,SAEL,YAARL,EACIO,KAAKH,QAAQC,KAAKK,aAAaR,GAC/BK,KAAKH,QAAQC,KAAKM,IAAIT,SAGzBU,SAAS,MACNH,EAASA,EAAOI,KAAO,WACtB,eACc,MAAVJ,gDAKRF,KAAKO,MAAMC,gBACTP,YAAYD,KAAKrB,OAGpBqB,KAAKH,QAAQC,MAAgB,YAARL,QAClBI,QAAQC,KAAKW,gBAAgBd,uDAK/Be,WAAY,oDAGOC,GAEtBpB,EACEb,qBAAqBsB,KAAKrB,OAC1BD,qBAAqBiC,GACrBX,KAAKY,qBAGFX,YAAYU,0CAqEgBX,KAAKO,MAAhCD,IAAAA,KAAMO,IAAAA,MAAOL,IAAAA,iBAEjBK,EACKxB,EACLyB,6BAACzB,cAAmBW,KAAKrB,OAAOkC,MAAOA,KACrC,KAEDL,EAGEM,6BAAC1C,cAAqB4B,KAAKrB,OAAOoC,UAAWT,KAF3ClB,EAAmB0B,6BAAC1B,EAAqBY,KAAKrB,OAAY,YAtJxCqC,mBACtB3C,uBAAyBF,eAAeC,SAExC6C,aAAe,MACdC,UAAUC,MAAM,WACTD,UAAUE,KAAKC,oBAChBH,UAAUE,KAAKC,eACpBH,UAAUE,KAAKC,wBACNH,UAAUE,KAAKC,2BACZH,UAAUE,KAAKC,+CAoEpCpB,YAAc,gBACRqB,WAECjB,SAAS,CAAEG,WAAW,EAAOF,KAAM,KAAMO,MAAO,aAGlC1B,EAAKR,GACtB,MAAOkC,YACFR,SAAS,CAAEG,WAAW,EAAMK,WAE1B,SAGLtC,UAAU+C,GAELA,EACJ7C,KAAK,gBACA8C,EAAKb,mBAGJL,SAAS,CAAEG,WAAW,EAAMF,SAC7BiB,EAAK1B,QAAQC,QACVD,QAAQC,KAAK0B,SAAS7B,EAAI,CAAEW,UAG5B,IAERmB,MAAM,gBACDF,EAAKb,gBAGG,YAARjB,aACS,WACJ8B,EAAKb,aACHL,SAAS,CAAEG,WAAW,EAAMK,WAElC,aAMKa,KAAK,iCAELA,KAAKb,KAGR,OAKRR,SAAS,CAAEG,WAAW,EAAMF,KAAMgB,EAAgBT,MAAO,QAGvD,SAGTD,YAAc,iBAAO,WACRW,EAAKhB,MAAMC,gBACfe,EAAKhB,MAAMM,WACZU,EAAKhB,MAAMD,eAkBdV,GC7LI,SAAS+B,uBAClBC,EAAY,EACV9B,EAAO,SACN,WACM,qBACI,YAGL,aACI,YAEJ,SAAC+B,EAAO3B,KACX2B,GAAS3B,OAEX,mBAASJ,EAAK+B,aACT,iBAAO,CAAE/B,cCVjBgC,mCAgCQnD,EAAOkB,iHACXlB,EAAOkB,WAKTlB,EAAMoD,cACFA,WAAWC,iGAKdD,WAAa/B,KAAKrB,MAAMoD,YAAcJ,wBACtCM,eAAiBjC,KAAKrB,MAAMsD,0EAI1B,MACC,WACOjC,KAAK+B,WAAWhC,mBACjBC,KAAK+B,WAAWP,aACrBxB,KAAK+B,WAAW3B,iBACP,mBAAMmB,EAAKU,eAAenC,KAAKH,oBAC5B,mBACR4B,EAAKU,eAAenC,KAAKH,8CAO/BmB,eAAMoB,SAASC,KAAKnC,KAAKrB,MAAMyD,iBA/DhBpB,iBAApBc,YACGO,UAAY,UACPnB,UAAUoB,KAAKjB,sBACbH,UAAUC,MAAM,WACfD,UAAUE,KAAKC,oBAChBH,UAAUE,KAAKC,oBACfH,UAAUE,KAAKC,eACpBH,UAAUE,KAAKC,oBACVH,UAAUE,KAAKC,4BAEXH,UAAUC,MAAM,MACxBD,UAAUqB,OAAOlB,cAXvBS,YAeGU,aAAe,YACR,oBACI,MACR,KAlBNV,YAsBGW,kBAAoB,MACnBvB,UAAUC,MAAM,WACTD,UAAUE,KAAKC,oBAChBH,UAAUE,KAAKC,eACpBH,UAAUE,KAAKC,wBACNH,UAAUE,KAAKC,2BACZH,UAAUE,KAAKC,aAC/BA"}